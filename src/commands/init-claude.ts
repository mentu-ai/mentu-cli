import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import type { Command } from 'commander';
import { MentuError } from '../types.js';

interface InitClaudeOptions {
  workspace?: string;
  actor?: string;
  force?: boolean;
}

interface InitClaudeOutput {
  created: string[];
  config_path: string;
  hooks_path: string;
}

function outputResult(result: InitClaudeOutput, json: boolean): void {
  if (json) {
    console.log(JSON.stringify(result));
  } else {
    console.log('Mentu Claude integration initialized');
    console.log('');
    console.log('Created:');
    for (const file of result.created) {
      console.log(`  ${file}`);
    }
    console.log('');
    console.log('Next steps:');
    console.log('  1. Set MENTU_PROXY_TOKEN environment variable');
    console.log('  2. Set MENTU_WORKSPACE_ID environment variable');
    console.log('  3. Claude Code will now auto-track all tasks');
  }
}

function outputError(error: MentuError, json: boolean): void {
  if (json) {
    console.log(JSON.stringify(error.toJSON()));
  } else {
    console.error(`Error: ${error.message}`);
  }
  process.exit(1);
}

export function registerInitClaudeCommand(program: Command): void {
  program
    .command('init-claude')
    .description('Initialize Mentu integration for Claude Code')
    .option('-w, --workspace <id>', 'Workspace ID')
    .option('-a, --actor <name>', 'Actor identity', 'agent:claude-code')
    .option('-f, --force', 'Overwrite existing files')
    .action((options: InitClaudeOptions) => {
      const json = program.opts().json || false;

      try {
        const projectRoot = process.cwd();
        const claudeDir = path.join(projectRoot, '.claude');
        const hooksDir = path.join(claudeDir, 'hooks');

        // Check for existing integration
        const configPath = path.join(claudeDir, 'mentu_config.yaml');
        if (fs.existsSync(configPath) && !options.force) {
          throw new MentuError(
            'E_WORKSPACE_EXISTS',
            'Mentu Claude integration already exists. Use --force to overwrite.'
          );
        }

        // Create directories
        fs.mkdirSync(hooksDir, { recursive: true });

        const created: string[] = [];

        // Find template files
        // In ESM, we need to resolve the path from the current module
        const __filename = fileURLToPath(import.meta.url);
        const __dirname = path.dirname(__filename);

        // Templates are in src/templates/ relative to dist/commands/
        // After build: dist/commands/init-claude.js -> src/templates/
        const mentuRoot = path.resolve(__dirname, '..', '..');
        const templatesDir = path.join(mentuRoot, 'src', 'templates');

        // Copy hook templates
        const hookFiles = [
          'mentu_pre_task.py',
          'mentu_post_task.py',
          'mentu_pr_events.py'
        ];

        for (const hookFile of hookFiles) {
          const srcPath = path.join(templatesDir, 'hooks', hookFile);
          const destPath = path.join(hooksDir, hookFile);

          if (fs.existsSync(srcPath)) {
            fs.copyFileSync(srcPath, destPath);
            fs.chmodSync(destPath, 0o755); // Make executable
          } else {
            // Fallback: create minimal placeholder
            fs.writeFileSync(destPath, `#!/usr/bin/env python3\n# ${hookFile}\n# Run: mentu init-claude to regenerate\n`);
            fs.chmodSync(destPath, 0o755);
          }
          created.push(`.claude/hooks/${hookFile}`);
        }

        // Create config
        const config = `# Mentu Integration for Claude Code
# Generated by: mentu init-claude

hooks:
  mentu:
    enabled: true
    api_url: "\${MENTU_API_URL:-https://mentu-proxy.affihub.workers.dev}"
    actor: "${options.actor || 'agent:claude-code'}"
    workspace_id: "${options.workspace || '${MENTU_WORKSPACE_ID}'}"

    triggers:
      - task_start
      - pr_create

    evidence_sources:
      - pr_merged
      - tests_passed
      - manual

    github:
      auto_push: true
      auto_close: true
`;
        fs.writeFileSync(configPath, config);
        created.push('.claude/mentu_config.yaml');

        // Update .gitignore
        const gitignorePath = path.join(projectRoot, '.gitignore');
        const mentuEntry = '\n# Mentu state\n.claude/mentu_state.json\n';

        if (fs.existsSync(gitignorePath)) {
          const content = fs.readFileSync(gitignorePath, 'utf-8');
          if (!content.includes('mentu_state.json')) {
            fs.appendFileSync(gitignorePath, mentuEntry);
          }
        }

        const result: InitClaudeOutput = {
          created,
          config_path: configPath,
          hooks_path: hooksDir,
        };

        outputResult(result, json);
      } catch (err) {
        if (err instanceof MentuError) {
          outputError(err, json);
        } else {
          const error = new MentuError(
            'E_INVALID_OP',
            err instanceof Error ? err.message : 'Unknown error'
          );
          outputError(error, json);
        }
      }
    });
}
