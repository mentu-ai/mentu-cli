/**
 * Document Generator - Generates PRD and HANDOFF documents
 *
 * Creates skeleton documents for T2/T3 tier items based on
 * memory content and classification.
 */

import type { Memory } from '../types.js';
import type { ClassificationResult, Tier } from './classifier.js';

export interface GeneratedDoc {
  path: string;
  content: string;
}

/**
 * Convert a title to a URL-friendly slug.
 */
export function toSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 50);
}

/**
 * Extract a title from the memory body.
 * Uses first line or first sentence.
 */
export function extractTitle(body: string): string {
  const firstLine = body.split('\n')[0].trim();
  // Remove leading action verbs for cleaner titles
  const cleanedLine = firstLine
    .replace(/^(implement|add|fix|update|create|build|refactor|remove|delete)\s+/i, '')
    .trim();

  return cleanedLine.length > 60
    ? cleanedLine.substring(0, 57) + '...'
    : cleanedLine;
}

/**
 * Extract mission statement from body.
 */
export function extractMission(body: string): string {
  const lines = body.split('\n').slice(0, 3);
  return lines.join('\n').trim() || '_To be defined_';
}

/**
 * Extract desired state patterns from body.
 */
export function extractDesiredState(body: string): string {
  // Look for "should", "will", "want", "need" patterns
  const patterns = [
    /should\s+(.+?)(?:\.|,|$)/gi,
    /will\s+(.+?)(?:\.|,|$)/gi,
    /want\s+(.+?)(?:\.|,|$)/gi,
    /need\s+(.+?)(?:\.|,|$)/gi,
  ];

  const extracted: string[] = [];

  for (const pattern of patterns) {
    const matches = [...body.matchAll(pattern)];
    for (const match of matches) {
      if (match[1] && match[1].length > 10) {
        extracted.push(`- ${match[1].trim()}`);
      }
    }
  }

  return extracted.length > 0
    ? extracted.slice(0, 5).join('\n')
    : '_Extracted from observation_';
}

/**
 * Extract success criteria from body.
 */
export function extractCriteria(body: string): string {
  // Look for numbered lists or bullet points
  const listPattern = /(?:^|\n)\s*[-*]\s*(.+)/gm;
  const matches = [...body.matchAll(listPattern)];

  if (matches.length > 0) {
    return matches
      .slice(0, 5)
      .map(m => `- [ ] ${m[1].trim()}`)
      .join('\n');
  }

  return '- [ ] _To be defined_';
}

/**
 * Extract summary from body.
 */
export function extractSummary(body: string): string {
  const firstTwo = body.split('\n').slice(0, 2).join(' ').trim();
  return firstTwo.length > 200
    ? firstTwo.substring(0, 197) + '...'
    : firstTwo;
}

/**
 * Get current date in ISO format.
 */
function getDate(): string {
  return new Date().toISOString().slice(0, 10);
}

/**
 * Generate a PRD document skeleton.
 */
export function generatePRD(
  memory: Memory,
  classification: ClassificationResult,
  commitmentId: string
): GeneratedDoc {
  const slug = toSlug(extractTitle(memory.body));
  const date = getDate();
  const title = extractTitle(memory.body);

  const content = `---
# ============================================================
# CANONICAL YAML FRONT MATTER
# ============================================================
id: PRD-${slug}-v1.0
path: docs/PRD-${slug}-v1.0.md
type: prd
intent: reference

# VERSIONING
version: "1.0"
created: ${date}
last_updated: ${date}

# TIER
tier: ${classification.tier}

# RELATIONSHIPS
children:
  - HANDOFF-${slug}-v1.0

# MENTU INTEGRATION
mentu:
  commitment: ${commitmentId}
  evidence: null
  status: pending
---

# PRD: ${title} v1.0

## Mission

${extractMission(memory.body)}

---

## Problem Statement

### Current State

_To be filled_

### Desired State

${extractDesiredState(memory.body)}

---

## Specification

_To be filled based on analysis_

---

## Success Criteria

${extractCriteria(memory.body)}

---

## References

- Source: ${memory.id}
- Created: ${date}
- Tier: ${classification.tier}
- Classification Reason: ${classification.reason}

---

*Generated by Mentu Triage Pipeline*
`;

  return {
    path: `docs/PRD-${slug}-v1.0.md`,
    content,
  };
}

/**
 * Generate a HANDOFF document skeleton.
 */
export function generateHANDOFF(
  memory: Memory,
  classification: ClassificationResult,
  commitmentId: string,
  prdPath: string
): GeneratedDoc {
  const slug = toSlug(extractTitle(memory.body));
  const date = getDate();
  const title = extractTitle(memory.body);

  const content = `---
# ============================================================
# CANONICAL YAML FRONT MATTER
# ============================================================
id: HANDOFF-${slug}-v1.0
path: docs/HANDOFF-${slug}-v1.0.md
type: handoff
intent: execute

# VERSIONING
version: "1.0"
created: ${date}
last_updated: ${date}

# TIER
tier: ${classification.tier}

# RELATIONSHIPS
parent: PRD-${slug}-v1.0
children:
  - PROMPT-${slug}-v1.0

# MENTU INTEGRATION
mentu:
  commitment: ${commitmentId}
  evidence: null
  status: pending

# VALIDATION
validation:
  required: true
  tier: ${classification.tier}
---

# HANDOFF: ${title} v1.0

## For the Coding Agent

${extractSummary(memory.body)}

**Read the full PRD**: \`${prdPath}\`

---

## Completion Contract

\`\`\`json
{
  "required_files": [],
  "checks": {
    "tsc": true,
    "build": true
  },
  "mentu": {
    "commitments": {
      "ids": ["${commitmentId}"]
    }
  }
}
\`\`\`

---

## Build Order

_To be filled based on PRD_

---

## Verification Checklist

- [ ] All required files created
- [ ] Build passes
- [ ] Tests pass
- [ ] Commitment submitted with evidence

---

## Mentu Protocol

\`\`\`bash
mentu claim ${commitmentId}
# ... do work ...
mentu submit ${commitmentId} --summary "Work completed" --include-files
\`\`\`

---

*Source: ${memory.id}*
*Tier: ${classification.tier}*
*Generated: ${date}*
`;

  return {
    path: `docs/HANDOFF-${slug}-v1.0.md`,
    content,
  };
}

/**
 * Generate both PRD and HANDOFF documents.
 */
export function generateDocs(
  memory: Memory,
  classification: ClassificationResult,
  commitmentId: string
): { prd: GeneratedDoc; handoff: GeneratedDoc } {
  const prd = generatePRD(memory, classification, commitmentId);
  const handoff = generateHANDOFF(memory, classification, commitmentId, prd.path);

  return { prd, handoff };
}

/**
 * Check if docs are required for a tier.
 */
export function docsRequired(tier: Tier, requireDocsTiers: Tier[] = ['T2', 'T3']): boolean {
  return requireDocsTiers.includes(tier);
}
