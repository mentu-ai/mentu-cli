import { describe, it, expect, beforeEach } from 'vitest';
import { timestamp, parseTimestamp, formatTimestamp } from '../../src/utils/time.js';

describe('Time Utilities', () => {
  describe('timestamp', () => {
    it('should generate ISO 8601 format', () => {
      const ts = timestamp();
      // ISO 8601: YYYY-MM-DDTHH:mm:ss.sssZ
      expect(ts).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    });

    it('should end with Z for UTC', () => {
      const ts = timestamp();
      expect(ts).toMatch(/Z$/);
    });

    it('should be parseable as Date', () => {
      const ts = timestamp();
      const date = new Date(ts);
      expect(date.toISOString()).toBe(ts);
    });

    it('should generate unique timestamps when called sequentially', () => {
      const ts1 = timestamp();
      const ts2 = timestamp();
      // Might be the same if called in same millisecond, but typically different
      expect(ts1).toBeTruthy();
      expect(ts2).toBeTruthy();
    });

    it('should generate recent timestamps', () => {
      const ts = timestamp();
      const date = new Date(ts);
      const now = new Date();

      // Should be within 1 second of now
      const diff = Math.abs(now.getTime() - date.getTime());
      expect(diff).toBeLessThan(1000);
    });

    it('should include milliseconds', () => {
      const ts = timestamp();
      expect(ts).toContain('.');
      const parts = ts.split('.');
      expect(parts).toHaveLength(2);
      expect(parts[1]).toMatch(/^\d{3}Z$/);
    });
  });

  describe('parseTimestamp', () => {
    it('should parse valid ISO 8601 timestamp', () => {
      const ts = '2025-01-15T10:30:00.000Z';
      const date = parseTimestamp(ts);
      expect(date).toBeInstanceOf(Date);
      expect(date.toISOString()).toBe(ts);
    });

    it('should parse timestamp generated by timestamp()', () => {
      const ts = timestamp();
      const date = parseTimestamp(ts);
      expect(date.toISOString()).toBe(ts);
    });

    it('should handle timestamps without milliseconds', () => {
      const ts = '2025-01-15T10:30:00Z';
      const date = parseTimestamp(ts);
      expect(date).toBeInstanceOf(Date);
      expect(date.getFullYear()).toBe(2025);
    });

    it('should preserve timezone information', () => {
      const ts = '2025-01-15T10:30:00.000Z';
      const date = parseTimestamp(ts);
      expect(date.getUTCHours()).toBe(10);
      expect(date.getUTCMinutes()).toBe(30);
    });

    it('should handle different valid ISO formats', () => {
      const formats = [
        '2025-01-15T10:30:00.123Z',
        '2025-01-15T10:30:00.000Z',
        '2025-12-31T23:59:59.999Z',
        '2025-01-01T00:00:00.000Z',
      ];

      for (const ts of formats) {
        const date = parseTimestamp(ts);
        expect(date).toBeInstanceOf(Date);
        expect(date.toISOString()).toBe(ts);
      }
    });
  });

  describe('formatTimestamp', () => {
    it('should format timestamp for display', () => {
      const ts = '2025-01-15T10:30:00.000Z';
      const formatted = formatTimestamp(ts);
      expect(formatted).toBeTruthy();
      expect(typeof formatted).toBe('string');
    });

    it('should produce locale-specific format', () => {
      const ts = '2025-01-15T10:30:00.000Z';
      const formatted = formatTimestamp(ts);
      // Should contain date components
      expect(formatted).toBeTruthy();
      // Format varies by locale, but should be readable
      expect(formatted.length).toBeGreaterThan(10);
    });

    it('should handle timestamp from timestamp()', () => {
      const ts = timestamp();
      const formatted = formatTimestamp(ts);
      expect(formatted).toBeTruthy();
      expect(typeof formatted).toBe('string');
    });

    it('should format different timestamps differently', () => {
      const ts1 = '2025-01-15T10:30:00.000Z';
      const ts2 = '2025-06-20T15:45:30.000Z';

      const fmt1 = formatTimestamp(ts1);
      const fmt2 = formatTimestamp(ts2);

      expect(fmt1).not.toBe(fmt2);
    });

    it('should produce human-readable output', () => {
      const ts = '2025-01-15T10:30:00.000Z';
      const formatted = formatTimestamp(ts);

      // Should contain some numeric date/time info
      expect(/\d/.test(formatted)).toBe(true);
    });
  });

  describe('timestamp roundtrip', () => {
    it('should survive parse -> format cycle', () => {
      const ts = timestamp();
      const parsed = parseTimestamp(ts);
      const roundtrip = parsed.toISOString();
      expect(roundtrip).toBe(ts);
    });

    it('should handle multiple roundtrips', () => {
      const original = '2025-01-15T10:30:00.123Z';

      const date1 = parseTimestamp(original);
      const ts1 = date1.toISOString();

      const date2 = parseTimestamp(ts1);
      const ts2 = date2.toISOString();

      expect(ts1).toBe(original);
      expect(ts2).toBe(original);
    });
  });
});
